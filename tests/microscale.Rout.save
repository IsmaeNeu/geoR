
R : Copyright 2002, The R Development Core Team
Version 1.6.1 Patched (2002-11-06)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type `license()' or `licence()' for distribution details.

R is a collaborative project with many contributors.
Type `contributors()' for more information.

Type `demo()' for some demos, `help()' for on-line help, or
`help.start()' for a HTML browser interface to help.
Type `q()' to quit R.

> require(geoR)
Loading required package: geoR 

------------------------------------------------
geoR - functions for geostatistical data analysis
geoR version 1.3-8 is now loaded
------------------------------------------------

[1] TRUE
> options(digits = 3, width = 80)
> set.seed(50)
> 
> op <- par(no.readonly=T)
> 
> dloc <- cbind((0:10)/10, 0)
> set.seed(274)
> dat <- grf(grid=dloc, cov.pars=c(1, .25), nug=.25)
grf: process with  1  covariance structure(s)
grf: nugget effect is: tausq= 0.25 
grf: covariance model 1 is: exponential(sigmasq=1, phi=0.25)
grf: decomposition algorithm used is:  cholesky 
grf: simulation on locations provided by the user
Loading required package: mva 
grf: End of simulation procedure. Number of realizations: 1 
> ploc <- cbind((0:1000)/1000, 0)
> 
> par(mfrow=c(3,1), mar=c(3,3,0,0), mgp=c(1.5,.8,0))
> 
> ##
> ## Predctions with option signal = F
> ##
> ## Here predictions "honor the data"
> kp1 <- krige.conv(dat, loc=ploc, krige=krige.control(cov.pars=c(1, .25), nug=.25, micro=0), out=output.control(signal=F))
krige.conv: model with constant mean
krige.conv: Kriging performed using global neighbourhood 
> image(dat)
simulation in 1-D
> lines(ploc[,1], kp1$pred)
> ## idem here
> kp2 <- krige.conv(dat, loc=ploc, krige=krige.control(cov.pars=c(1, .25), nug=.25, micro=0.25), out=output.control(signal=F))
krige.conv: model with constant mean
krige.conv: Kriging performed using global neighbourhood 
> image(dat)
simulation in 1-D
> lines(ploc[,1], kp2$pred)
> ## and here
> kp3 <- krige.conv(dat, loc=ploc, krige=krige.control(cov.pars=c(1, .25), nug=.25, micro=0.125), out=output.control(signal=F))
krige.conv: model with constant mean
krige.conv: Kriging performed using global neighbourhood 
> image(dat)
simulation in 1-D
> lines(ploc[,1], kp3$pred)
> 
> ##
> ## Now predictions with signal = T
> ##
> ## Here we predict the signal
> kp4 <- krige.conv(dat, loc=ploc, krige=krige.control(cov.pars=c(1, .25), nug=.25, micro=0), out=output.control(signal=T))
krige.conv: model with constant mean
krige.conv: Kriging performed using global neighbourhood 
> image(dat)
simulation in 1-D
> lines(ploc[,1], kp4$pred)
> ## here we "honor the data" because microscale = nugget
> kp5 <- krige.conv(dat, loc=ploc, krige=krige.control(cov.pars=c(1, .25), nug=.25, micro=0.25), out=output.control(signal=T))
krige.conv: model with constant mean
krige.conv: Kriging performed using global neighbourhood 
> image(dat)
simulation in 1-D
> lines(ploc[,1], kp5$pred)
> ## and here we are between the prevuious two
> kp6 <- krige.conv(dat, loc=ploc, krige=krige.control(cov.pars=c(1, .25), nug=.25, micro=0.125), out=output.control(signal=T))
krige.conv: model with constant mean
krige.conv: Kriging performed using global neighbourhood 
> image(dat)
simulation in 1-D
> lines(ploc[,1], kp6$pred)
> 
> ##
> ##
> ##
> data(s100)
> loci <-  rbind(s100$coords[1,],c(0.5,0.5))
> 
> kc <- krige.control(cov.pars=c(1,1), nugget = 1, micro.scale = 0)
> 
> oc <- output.control(signal=F, mess=F)
> lapply(krige.conv(s100, locations =loci, krige= kc, output=oc)[1:2], round, dig=4)
$predict
[1] 0.917 0.968

$krige.var
[1] 0.00 1.14

> oc <- output.control(signal=T, mess=F)
> lapply(krige.conv(s100, locations =loci, krige= kc, output=oc)[1:2], round, dig=4)
$predict
[1] 1.247 0.968

$krige.var
[1] 0.161 0.139

> ##
> ##
> ##
> kc <- krige.control(cov.pars=c(1,1), nugget = 1, micro.scale = 1)
> 
> oc <- output.control(signal=F, mess=F)
> lapply(krige.conv(s100, locations =loci, krige= kc, output=oc)[1:2], round, dig=4)
$predict
[1] 0.917 0.968

$krige.var
[1] 0.00 1.14

> oc <- output.control(signal=T, mess=F)
> lapply(krige.conv(s100, locations =loci, krige= kc, output=oc)[1:2], round, dig=4)
$predict
[1] 0.917 0.968

$krige.var
[1] 0.00 1.14

> ##
> ##
> kc <- krige.control(cov.pars=c(1,1), nugget = 1, micro.scale = 0.5)
> 
> oc <- output.control(signal=F, mess=F)
> lapply(krige.conv(s100, locations =loci, krige= kc, output=oc)[1:2], round, dig=4)
$predict
[1] 0.917 0.968

$krige.var
[1] 0.00 1.14

> oc <- output.control(signal=T, mess=F)
> lapply(krige.conv(s100, locations =loci, krige= kc, output=oc)[1:2], round, dig=4)
$predict
[1] 1.082 0.968

$krige.var
[1] 0.290 0.638

> 
> 
> 
